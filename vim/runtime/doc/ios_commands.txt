*ios_commands.txt*	For Vim version 7.4	Last change: 2018 May 18

			iVim REFERENCE MANUAL	by Terry Chou

						*ios-commands* *icommands*

This file describes the details of the ex commands added by iVim to support 
its features.

1. Font Management		|font-management-icommands|
2. Share			|share-icommands|
3. Exuberant Ctags		|ctags-icommand|
4. Open URL			|open-url-icommand|
5. Set Extended Keyboard	|set-extended-keyboard-icommands|

==============================================================================
1. Font Management				*font-management-icommands*

iVim adds two commands to assist the font management |ios-font-management|.

:ifo[nt] [fnum|fname] [fsize]				*:ifo* *:ifont*
		Without arguments, it shows all available fonts. Example: 

			*1	s	SourceCodePro-Regular	14.0 ~
			2	s	Menlo-Regular ~
			3	u	LucidaConsole ~

		The first column shows the order number of each font. The 
		currently used font has a `*` prepended to its number. The
		second column is the type indicator of the font:
			s  system font
			u  user font

		The third column stands for the font name. Also, the current
		font will have an extra column indicating its size. After
		new fonts are imported or existing ones deleted, this list
		will change accordingly.

		To set the current font, give the font number or font name as
		the argument. Example: >
			:ifont 3		"set the font to LucidaConsole
			:ifont Menlo-Regular	"set the font to Menlo-Regular
			:ifont Sou		"set the font to
						"SourceCodePro-Regular
<		Prefix can be given as the font name, the first matched font
		will be set.
		After the font number or name, a number can be given to set
		the font size at the same time. Example: >
			:ifont 3 12		"set the font to LucidaConsole
						"and to size 12.0
<		If the font size is not an integer, its fractional part will 
		be cut.
		You can use `_` as the font name to indicate that you want to
		keep the current font. Example: >
			:ifont _ 12		"keep the current font and set
						"its size to 12.0
<
		Note: the font setting of |:ifont| is temporary, it will 
		change back to the default one at next app launch. To set the 
		font permanently, add `set guifont={fname}:h{fsize}` into 
		vimrc.

:idel[etefont] [fnum|fname]				*:idel* *:ideletefont*
		Like |:ifont|, it shows all available fonts when no arguments
		are following.

		To delete a font, indicate the font number or font name as the
		target. Example: >
			:idel 3			"delete font LucidaConsole
			:idel Luc		"delete font LucidaConsole
<		If the current font is deleted, the first system font will be
		used.

		Note that only user fonts can be deleted.


==============================================================================
2. Share						*share-icommands*

iVim has two commands for sharing |ios-share|.

:[range]ish[are] [fname]				*:ish* *:ishare*
		Share files or text with other apps via the share extension.
		
		When [range] is given, text of lines in it of current buffer
		will be shared. Example: >
			:3,8ishare		"share text of line 3 thro 8
<
		Otherwise, the file represented by [fname] will be shared: >
			:ishare todo		"share file `todo` under 
						"current directory
			:ishare			"share file of current window 
<
		Note: only one file can be shared at a time.

:idoc[uments] [open|import]				*:idoc* *:idocuments*
		Pick documents from iCloud Drive or other document provider
		apps via the document picker.

		When the option is `open` or omitted, the picked document will
		be edited in place, meaning that the modifications will be
		saved back to the original document directly. Example: >
			:idoc			"open the document picker
						"and edit the picked file
						"in place
<		If the option is `import`, the picked document will be copied
		into iVim's `Documents` directory and opened for further
		editing. 

		Note: the imported file will be renamed if there has been 
		a file already possesses that name.


==============================================================================
3. Exuberant Ctags					*ctags-icommand*

iVim offers one command to use the integrated Exuberant Ctags
|ios-exuberant-ctags|.

:ic[tags] {options} [fname]				*:ic* *:ictags*
		Run the integrated Exuberant Ctags like the shell command.
		
		Examples: >
			:ictags --help		"show help info of ctags
			:ictags -R .		"generate tags recusively
						"for files under current
						"working directory
<
		Also, it supports vim |wildcards| in file or directory names.
		Example: >
			:ictags *.c *.h		"generate tags for all .c and
						".h files under current dir
<
		Note: option 'fileignorecase' is on by default, it will ignore
		case in file names when expanding them.

		After the tags are generated, you can browse the codebase 
		easily by |tags| navigation commands.

		Note: big projects may take some time to finish.


==============================================================================
4. Open URL						*open-url-icommand*

iVim adds one command to support the URL scheme opening |ios-open-url|.

:io[penurl] {url}					*:io* *:iopenurl*
		Open the {url} to invoke the iOS URL scheme workflow.

		Example: >
			:io https://www.example.com/search?q={@*%[Q}
<
		It will launch Safari and open the site "www.example.com" and
		do a search with the contents in the clipboard as the query.
		
		Note that it opens only one URL at a time.

Variable token ~

You need to use variable tokens to include useful info into an URL. The format
for a variable token is "{expr%[encode}". 

a. the "{" and "}" are the opening and closing delimiter respectively. 

As a result, they need to be backslash-escaped if you want to use them 
literally in the URL. Note that nested token is not supported.

b. the "expr" is a vim |expression| which will be replaced with its value when 
the whole URL is opened.

This expression will be evaluated by vim and errors will be given if it is
invalid. Note a) only expressions with value type "string" and "number" are
supported. b) tokens are evaluated one by one from left to right.

c. the "%[" is the indicator for a following URL encoding type.

d. the "encode" is the URL encoding type which is explained in details below.

Backslash escape ~

Sometimes you need to put certain characters literally into an URL. You can 
put a backslash character before each to achieve this. For example, "\{expr\}"
will be treated literally instead of a variable token.

Because of its special meaning, a literal backslash always needs to be 
backslash escaped, e.g. "\\".

URL encoding ~

Certain characters in an URL need to be percent encoded for a successful
opening. Moreover, in different parts of an URL, the characters that need 
encoding differ. iVim provides an URL encoding type to help with this.

A typical URL skeleton is 
>
	scheme://user:password@host:port/path?query#fragment
<
The following encoding types are available:

	U:	indicates encoding for "user" part
	PW:	"password" part
	H:	"host" part
	PT:	"path" part
	Q:	"query" part, it is the default
	F:	"fragment" part

For example, if you will include a variable token into the "host" part, you
need to indicate it as "{expr%[H}". Then iVim will encode its value for the
specific part automatically. Omitting the encoding part, e.g. "{expr}", will 
encode it for the default "query" part. Note that they are case insensitive.
e.g. "%[Q" and "%[q" mean the same encoding.

Debug errors ~

iVim provides some debug errors when you try to open an URL but it has some
problems.

"token open character { expected":
	a closing delimiter is encountered before an opening one.
"token close character } expected": 
	one opening delimiter is expecting a closing one but none given.
"nested token not allowed":
	you are trying to put a variable token inside another one.
"unfinished character escaping":
	there is a backslash at the end of the URL.
"invalid path: ...":
	the URL is invalid
"failed to open URL: ...":
       	the system failed to open the given URL.
	
If the position of the problem can be located in the URL, it will be 
highlighted as ">...<".


==============================================================================
5. Set Extended Keyboard		*set-extended-keyboard-icommand*

iVim offers one command for customizing the extended keyboard.

:iset[ekbd] [operation] [configuration]			*:iset*	*:isetekbd*
		Set the extended keyboard according to the given [operation]
		or [configuration].
		
		"isetekbd" means "iset extended keyboard".

Concepts ~

The extended keyboard consists of compact buttons, each of which, in turn, 
contains some keys. By editing its default buttons or keys, you can customize
the extended keyboard to meet your own needs.

The editings such as remove, append or insert are called operations. According
to the arguments obtained from the configuration, they change the buttons or
keys. The format of the configuration is given below.

Configuration format ~

The configuration is written in vim's |dict|, |list| or their mixing. For 
example:>
	:isetekbd {'operation':'remove', 'locations':[0]}
<
this command will remove the button at location 0. The configuration is given
as a vim |dict|, and its property `locations` is a vim |list|.

						*isetekbd-operation-node*
This kind of dict in the above example is called a node. It contains necessary
properties to fulfill the operation. More specifically, the above dict is an
operation node, which may have the following properties:

a. operation

it gives the name of the operation. An error will emerge if it is not one of
the available operations (introduced below). A special characteristic of this
property is that you can give it as a subcommand of the command |:isetekbd|
therefore put it outside of the dict:>
	:isetekbd remove {'locations':[0]}
<
this command is the same as the last one. And this is the reason of the 
[operation] part's existence of the command. When an operation is given as a
subcommand, it will be added to the following configuration as the `operation` 
property: one if the following configuration is a dict; or one for each if a 
list, meaning an operations group.

Note this property is mandatory.

b. locations

it means locations of buttons for this operation. As shown in the example, it
is a integer list and zero-based (button location starts at zero). An error
will appear if any location is out of the legal bounds.

c. buttons

it is a list of button nodes |isetekbd-button-node| providing information on 
the button level for the operation. For example:>
	:isetekbd remove {'locations':[0], 'buttons':[{'locations':[1]}]}
<
this will remove the second key on the first button. The target locations of
keys need to be given in the button node.

d. arguments

it contains information for operations that require plain arguments.

As you can see, except for `operation`, which property is necessary depends
on the specific operation. Each operation will try and seek the properties it
needs, and ignore the rest.

						*isetekbd-button-node*
As mentioned above, a button node provides the button level information for
an operation. The following properties may be available:

a. locations

it is an integer list indicating the locations of keys on this button. It is
an error if any location is outside of the legal range.

b. keys

it is a list of key nodes |isetekbd-key-node| providing new keys information 
when necessary.

						*isetekbd-key-node*
A key node is for making a new key. It contains the following properties:

a. title

it is the text shown as the key on a button.

b. type

there are several key types for different scenarios:

1) command

it means that an ex command indicated in `contents` will be invoked:>
	{'title':'Fs', 'type':'command', 'contents':'isetekbd source funcs'}
<
it will run command ":isetekbd source funcs", therefore change the extended
keyboard according to the configuration file "funcs", when this key is 
triggered.

2) insert

it means that the characters in `contents` will be inserted:>
	{'title':'A', 'type':'insert', 'contents':'A'}
<
it will insert the uppercase 'A' whenever the key is triggered.

3) modifier

it means that it will be the modifier key indicated in `contents`:>
	{'title':'D', 'type':'modifier', 'contents':'command'}
<
it will be the Command key |<D-|.

The following modifier keys are supported:	*isetekbd-modifier-keys*
	
	'alt':		the alt key |<A-|
	'command':	the Command key |<D-|
	'control':	the control key |<C-|
	'meta':		the meta key |<M-|
	'shift':	the shift key |<S-|

If the key name is not found among the above, it shows an error.

Note that a modifier key will be sticky like the default `ctrl` key.

4) special

for iVim to work properly, some keys need to be handled in a special way. You
can make a special key by indicating it in `contents`:>
	{'title':'esc', 'type':'special', 'contents':'esc'}
<
this will the `esc` key. Note that it is different from simply running the
command ":call feedkeys('\<Esc>')" because iVim does other things when `esc`
is pressed.

The following special keys are available:	*isetekbd-special-keys*

	'esc':		the esc key
	'up':		the arrow Up
	'down':		the arrow Down
	'left':		the arrow Left
	'right':	the arrow Right
	'tab':		the tab key

If the key name is not found among the above, it shows an error.


Note that it is an error if the key type is not one of the available ones.

c. contents

together with the key type, it decides what it will do when the key is 
triggered.
 
Editing modes ~					*isetekbd-modes*

There are several different situations in which the editing behavior will 
differ:

a. compose

when a |:isetekbd| command is ran directly from the ex command line, it is
in the compose mode. In this mode, each editing will be recorded into the
editing history. As a result, you can tune the editing by manipulating 
the history: you can give up the last editing with the `undo` operation; 
resume it with the `redo` operation; save the editings in the history into
a configuration file for future use when you are content with the result.

The result of each editing (i.e. each |:isetekbd| command) will be reflected
on the extended keyboard immediately.

b. vim source

if a |:isetekbd| command is from a file being sourced by vim, e.g. in the 
.vimrc file, it is in the vimsource mode. In this case, the editing will not 
be recorded into the editing history. However, the result of each editing 
will be applied immediately.

c. source

editing entries could also be saved into a configuration file and be applied
by the `source` operation later. Except for the outmost `source` operation,
all the editing entries in the configuration file will not be recorded into
the editing history in this mode. Also for the sake of efficiency, the 
changes will not be applied to the extended keyboard until the end of the 
sourcing operation.

iVim will change into related mode automatically when the situation comes.

Operations ~					*isetekbd-operations*

The |:isetekbd| command fulfills its function through different operations.
The available operations and their details are listed as following:

a. remove

it removes buttons or keys on specific buttons. 

For the locations of target buttons, it will seek the `locations` property 
of the operation node. For example:>
	:isetekbd remove {'locations':[3,7]}
<
this command will remove buttons at locations 3 and 7.

If the `buttons` property also presents, it will try and associate located
buttons with the button nodes in it one by one and orderly. If a located 
button finds its associated node and a non-empty `locations` property in the
node also presents, this button will be treated as a key-removing button and
the related keys will be removed from it. For example:>
	:isetekbd remove {'locations':[5,2],
			\'buttons':[{'locations':[3]}]}
<
this will remove the key at location 3 of the button at 5, and remove the 
button at 2. In this example, the button 5 finds a associated node in the 
buttons list and is considered as a key-removing button. On the other hand,
button 2 fails to associate any node therefore is removed as a button.

b. append

it appends new buttons to the end of the extended keyboard bar, or new keys
to the end of the specific button.

For the new buttons, it will seek the `buttons` property. Example:>
	:isetekbd append {'buttons':[
				    \{'keys':[
					     \{'title':'C',
					     \ 'type':'modifier',
					     \ 'contents':'control'}
					     \]},
				    \{'keys':[
					     \{'title':'D',
					     \ 'type':'modifier',
					     \ 'contents':'command'}
					     \]}
				    \]}
<
this will append two new buttons, the first with a modifier `control` key and
the second a modifier `command`, to the end of the current extended keyboard.

If the `locations` property also presents in the operation node, it tries and 
associates the button nodes in `buttons` with locations in `locations` one by
one and orderly. Any associated button node will be key-appending, meaning
new keys generated from its `keys` property will be appended to the end of
the button at its associated location. Example:>
	:isetekbd append {'buttons':[
				    \{'keys':[
					     \{'title':'C',
					     \ 'type':'modifier',
					     \ 'contents':'control'}
					     \]},
				    \{'keys':[
					     \{'title':'D',
					     \ 'type':'modifier',
					     \ 'contents':'command'}
					     \]}
				    \],
			 \'locations':[3]}
<
because of the presence of the `locations` property, this command will append
a new modifier `control` key to the end of the button 3, and a new button with
a modifier `command` key to the end of the extended keyboard.

Note that iVim will hide buttons or keys if they exceed their respective
visual limits (enough space on extended keyboard bar for buttons; 5 for keys).

c. insert

it inserts new buttons or new keys to the specific button.

For the new buttons, it seeks the `buttons` property. For the target locations 
of them, it seeks the `locations` property of the operation node. Example:>
	:isetekbd insert {'buttons':[
				    \{'keys':[
					     \{'title':'C',
					     \ 'type':'modifier',
					     \ 'contents':'control'}
					     \]},
				    \{'keys':[
					     \{'title':'D',
					     \ 'type':'modifier',
					     \ 'contents':'command'}
					     \]}
				    \],
			 \'locations':[3,5]}
<
this will insert a button with a modifier `control` key to location 3, and a 
button with a modifier `command` key to location 5. Note that the insertion is
processed in the order of the locations, so later locations should take the 
results of earlier ones into account. e.g. the location 5 in the above example
is the new location 5 after the insertion at location 3.

It respects the locations more, which means the size of button nodes for new 
buttons should be enough for locations, it is an error otherwise.

If a button node also has a non-empty `locations` property, it means the new
keys in the `keys` property will be inserted to the button at the locations
indicated by it. Example:>
	:isetekbd insert {'buttons':[
				    \{'keys':[
					     \{'title':'C',
					     \ 'type':'modifier',
					     \ 'contents':'control'}
					     \]},
				    \{'keys':[
					     \{'title':'D',
					     \ 'type':'modifier',
					     \ 'contents':'command'}
					     \],
				     \'locations':[2]}
				    \],
			 \'locations':[3,5]}
<
this command will still insert a new button generated by the first button node
to location 3 like the last example; however, it will not insert a new button
at location 5, rather, it inserts the new modifier `command` key at location 2
on button 5.

Likewise, the key-insertion locations should also take the order significantly.
And the key nodes should always be enough for the target locations.

d. replace

it replaces buttons or keys on the specific button with new ones.

It seeks the `locations` property for the locations of the buttons to be 
replaced. For the new buttons, it seeks the `buttons` property. Example:>
	:isetekbd replace {'buttons':[
				     \{'keys':[
					      \{'title':'C',
					      \ 'type':'modifier',
					      \ 'contents':'control'}
					      \]},
				     \{'keys':[
					      \{'title':'D',
					      \ 'type':'modifier',
					      \ 'contents':'command'}
					      \]}
				     \],
			  \'locations':[3,5]}
<
this replaces button 3 with a new one that has a modifier `control` key, and
button 5 with one that has a modifier `command` key.

Like operation insert, the size of button nodes should be enough for that of
the target locations. Or it is an error.

If a button node has the `locations` property, instead of replacing this 
button, it will replace the keys indicated by this property with new ones in
the `keys` property. Example:>
	:isetekbd replace {'buttons':[
				     \{'keys':[
					      \{'title':'C',
					      \ 'type':'modifier',
					      \ 'contents':'control'}
					      \]},
				     \{'keys':[
					      \{'title':'D',
					      \ 'type':'modifier',
					      \ 'contents':'command'}
					      \],
				      \'locations':[2]}
				     \],
			  \'locations':[3,5]}
<
the difference of this command is that it replaces the key 2 on button 5 with
one modifier `command`, rather than replace the button altogether.

Also, the size of key nodes should be enough for the target locations for key
replacing.

e. clear

it removes all existing buttons from the extended keyboard.

It requires no other properties. Example:>
	:isetekbd clear
<

f. default

it makes the extended keyboard revert to its default state.

It requires no other properties. Example:>
	:isetekbd default
<

g. source

it reads configuration files and applies them to the extended keyboard.

The trailing part of a |:isetekbd| invoking (the part without the command 
name, e.g. remove {'locations':[3]}) is called an editing item. A 
configuration file is comprised of editing items, one on each line.

The `source` operation reads the configuration file line by line and process 
them in order. As mentioned above, it is in the `source` mode while a config
file is being sourced. Therefore, changes brought by each editing item won't
be applied until the outmost (it could be recursive) sourcing procedure is 
done.

It accepts multiple configuration files at once, and will process them in
order. Example:>
	:isetekbd source cfile1 cfile2 cfile3 ...
<

In a configuration file, all whitespaces at the beginning of each line will be
ignored. And a line will be treated as a comment if it begins with a double 
quote '"', for example:>
	"this is a comment
	remove {'locations':[3]}
<
and a line will be the continuation of its last line if it begins with a
backslash '\', and they will be treated as one line altogether, example:>
	replace {
		\'locations":[2],
		\'buttons':[
			\{'keys':[
				\{'title':'C',
				\ 'type':'modifier',
				\ 'contents':'control'}]}]
		\}
<

The 7 ones above are editing operations that modify buttons or keys on the 
extended keyboard.

h. compose

it resets the compose mode.

In the `compose` mode, each time it is called, it clears the existing editing 
history and set the current state as the first history entry. As a result, it
makes a clean environment for the composition. Example:>
	:isetekbd compose
<
Since it doesn't  makes sense otherwise, it can only be called in `compose`
mode as a single operation (cannot be a member of a operations group).>
	:isetekbd [
		  \{'operation':'compose'},
		  \{'operation':'remove',...}
		 \]
<
the above example will show an error because it is a member of an operation
group.

i. undo

it goes back to the previous state in the editing history.

It requires no further arguments, example:>
	:isetekbd undo
<
An error shows if there is no previous entry in the history.

Like operation `compose`, it is only allowed in `compose` mode as a single
operation. It is an error otherwise.

j. redo

it goes to the next state in the editing history.

It requires no further arguments, example:>
	:isetekbd redo
<
An error shows if there is no more entry in the history.

Likewise, it is only allowed in `compose` mode as a single operation.

k. export

it writes current items in the editing history to configuration files.

The items in the editing history are those that have been making the extended
keyboard to its current state since the beginning of the related `compose` 
mode. Therefore, the outcome of the `export` operation is configuration files
that can be sourced by the `source` operation in the future.

It accepts multiple files at once, and writes the contents to each of them:>
	:isetekbd export cfile1 cfile2 ...
<
You can peek the contents by invoking it without any target file:>
	:isetekbd export
<
this command prints the contents in the ex command line window.

It is only allowed as a single operation in `compose` mode.

The 4 ones above are helper operations to assist editing in `compose` mode.


 vim:tw=78:ts=8:ft=help:norl:
